# advprog-modul6

Commit 1 Reflection notes
    Pada commit 1 saya belajar mengenai bagaimana bahasa Rust menjembatani protokol kontrol transmisi
    dari suatu stream data, dimana pada tiap stream/koneksi jaringan yang terhubung akan dieksekusi oleh
    iterator. Tiap iterasi akan mentrigger unwrap() untuk memvalidasi keabsahan stream dan jika terjadi error, unwrap() akan segera menghentikan program yang berjalan. Diasumsikan stream koneksi berjalan dengan lancar, compiler kemudian akan mem-pass stream kedalam method penanganan koneksi. Didalam method terkait yang menerima input koneksi mutable (memungkinkan I/0 pada stream terkait), dilakukan operasi buf_reader sebagai pustaka stream reading secara efisien, setelah itu kode akan menciptakan suatu request http dengan tipe data vector sebagai container stream, dimana buf_reader akan mentrigger iterator lines() untuk mengiterasi tiap input stream, kemudian mengambil nilai string dari result pada stream input, dan kemudian menghentikan iterasi ketika kode membaca input baris kosong, setelahnya compiler akan mengumpulkan semua header HTTP ke dalam Vec<_>. Kemudian mencetak permintaan HTTP menuju server ke terminal.

Commit 2 Reflection notes
    Pada commit 2 saya belajar mengenai bagaimana bahasa Rust membentuk dan mengirimkan respons HTTP setelah menerima permintaan dari klien. Setelah semua header HTTP dikumpulkan dalam sebuah vektor, compiler akan menyiapkan respons HTTP dengan menentukan status respons sebagai "HTTP/1.1 200 OK", yang menandakan bahwa permintaan berhasil diproses oleh server. Selanjutnya, kode akan membaca file hello.html dari sistem menggunakan fs::read_to_string(), yang akan memuat seluruh isi file ke dalam variabel contents. Setelah konten berhasil dibaca, compiler akan menghitung panjang isi file dalam satuan byte menggunakan method .len(), yang nantinya akan digunakan dalam header Content-Length untuk memberi tahu klien mengenai ukuran konten yang akan dikirim. Setelah itu, compiler akan menyusun respons HTTP dalam bentuk string dengan menggunakan format!(), yang menggabungkan status respons, panjang konten, serta isi dari hello.html ke dalam satu string HTTP yang sesuai dengan standar protokol. Terakhir, kode akan mengirimkan respons tersebut ke klien dengan memanggil write_all(), yang akan menuliskan seluruh byte dari string respons ke dalam stream koneksi. Jika terjadi error dalam proses ini, method .unwrap() akan segera menghentikan program yang berjalan.

![Commit 2 screen capture](/assets/images/commit2.png)

Commit 3 Reflection notes
    Pada commit ini, saya belajar mengenai bagaimana bahasa Rust menangani error ketika menerima koneksi jaringan yang gagal. Setiap koneksi masuk direpresentasikan sebagai stream, yang kemudian diproses dalam loop for stream in listener.incoming(). Dalam implementasi awal, pemanggilan .unwrap() langsung pada hasil dari listener.incoming() dapat menyebabkan panic apabila terjadi error saat menerima koneksi, misalnya jika koneksi terputus tiba-tiba atau terjadi kesalahan sistem. Untuk mengatasi hal ini, digunakan match stream, di mana jika koneksi berhasil (Ok(stream)), maka akan diproses lebih lanjut dengan memanggil handle_connection(stream). Sebaliknya, jika terjadi error (Err(e)), maka pesan kesalahan akan dicetak menggunakan eprintln!() tanpa menghentikan eksekusi program. Dengan pendekatan ini, server dapat terus berjalan meskipun terdapat koneksi yang gagal, sehingga meningkatkan stabilitas sistem dan memastikan bahwa kesalahan yang terjadi tidak mengganggu koneksi lainnya.