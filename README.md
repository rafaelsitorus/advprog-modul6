# advprog-modul6

Commit 1 Reflection notes
    Pada commit 1 saya belajar mengenai bagaimana bahasa Rust menjembatani protokol kontrol transmisi
    dari suatu stream data, dimana pada tiap stream/koneksi jaringan yang terhubung akan dieksekusi oleh
    iterator. Tiap iterasi akan mentrigger unwrap() untuk memvalidasi keabsahan stream dan jika terjadi error, unwrap() akan segera menghentikan program yang berjalan. Diasumsikan stream koneksi berjalan dengan lancar, compiler kemudian akan mem-pass stream kedalam method penanganan koneksi. Didalam method terkait yang menerima input koneksi mutable (memungkinkan I/0 pada stream terkait), dilakukan operasi buf_reader sebagai pustaka stream reading secara efisien, setelah itu kode akan menciptakan suatu request http dengan tipe data vector sebagai container stream, dimana buf_reader akan mentrigger iterator lines() untuk mengiterasi tiap input stream, kemudian mengambil nilai string dari result pada stream input, dan kemudian menghentikan iterasi ketika kode membaca input baris kosong, setelahnya compiler akan mengumpulkan semua header HTTP ke dalam Vec<_>. Kemudian mencetak permintaan HTTP menuju server ke terminal.

Commit 2 Reflection notes
    Pada commit 2 saya belajar mengenai bagaimana bahasa Rust membentuk dan mengirimkan respons HTTP setelah menerima permintaan dari klien. Setelah semua header HTTP dikumpulkan dalam sebuah vektor, compiler akan menyiapkan respons HTTP dengan menentukan status respons sebagai "HTTP/1.1 200 OK", yang menandakan bahwa permintaan berhasil diproses oleh server. Selanjutnya, kode akan membaca file hello.html dari sistem menggunakan fs::read_to_string(), yang akan memuat seluruh isi file ke dalam variabel contents. Setelah konten berhasil dibaca, compiler akan menghitung panjang isi file dalam satuan byte menggunakan method .len(), yang nantinya akan digunakan dalam header Content-Length untuk memberi tahu klien mengenai ukuran konten yang akan dikirim. Setelah itu, compiler akan menyusun respons HTTP dalam bentuk string dengan menggunakan format!(), yang menggabungkan status respons, panjang konten, serta isi dari hello.html ke dalam satu string HTTP yang sesuai dengan standar protokol. Terakhir, kode akan mengirimkan respons tersebut ke klien dengan memanggil write_all(), yang akan menuliskan seluruh byte dari string respons ke dalam stream koneksi. Jika terjadi error dalam proses ini, method .unwrap() akan segera menghentikan program yang berjalan.

![Commit 2 screen capture](/assets/images/commit2.png)

Commit 3 Reflection notes
    Pada commit 3 saya belajar mengenai bagaimana bahasa Rust menangani error ketika menerima koneksi jaringan yang gagal. Setiap koneksi masuk direpresentasikan sebagai stream, yang kemudian diproses dalam loop for stream in listener.incoming(). Dalam implementasi awal, pemanggilan .unwrap() langsung pada hasil dari listener.incoming() dapat menyebabkan panic apabila terjadi error saat menerima koneksi, misalnya jika koneksi terputus tiba-tiba atau terjadi kesalahan sistem. Untuk mengatasi hal ini, digunakan match stream, di mana jika koneksi berhasil (Ok(stream)), maka akan diproses lebih lanjut dengan memanggil handle_connection(stream). Sebaliknya, jika terjadi error (Err(e)), maka pesan kesalahan akan dicetak menggunakan eprintln!() tanpa menghentikan eksekusi program. Dengan pendekatan ini, server dapat terus berjalan meskipun terdapat koneksi yang gagal, sehingga meningkatkan stabilitas sistem dan memastikan bahwa kesalahan yang terjadi tidak mengganggu koneksi lainnya.

![Commit 3 screen capture](/assets/images/commit3.png)

Commit 4 Reflection notes
    Pada commit 4 ini saya belajar mengenai dampak dari server single-threaded dalam menangani permintaan yang lambat. Dengan menambahkan fitur sleep pada route /sleep, saya mensimulasikan bagaimana satu permintaan dapat memblokir seluruh server selama 10 detik sebelum merespons. Hal ini terjadi karena server hanya menggunakan satu thread, sehingga ketika satu permintaan sedang diproses, tidak ada thread lain yang tersedia untuk menangani permintaan baru. Akibatnya, jika ada beberapa klien yang mengakses server secara bersamaan, mereka harus menunggu hingga permintaan sebelumnya selesai sebelum mendapatkan respons. Masalah ini menunjukkan keterbatasan pendekatan single-threaded dalam lingkungan yang memerlukan kinerja tinggi dan respons cepat.

Commit 5 Reflection notes
    Pada commit 5 ini saya belajar mengenai konsep thread pool dan bagaimana penggunaannya dapat meningkatkan performa server. Dengan menggunakan thread pool, server dapat menangani banyak permintaan secara bersamaan tanpa harus membuat thread baru untuk setiap koneksi, yang dapat menyebabkan overhead dan konsumsi sumber daya yang berlebihan. Thread pool bekerja dengan menyediakan sejumlah thread yang telah dibuat sebelumnya dan siap digunakan untuk menangani permintaan yang masuk. Ketika ada permintaan baru, thread yang tersedia akan mengambil tugas tersebut, sementara permintaan lain dapat diproses oleh thread lain yang masih bebas. Dengan cara ini, server dapat melayani banyak klien secara efisien tanpa mengalami bottleneck seperti pada model single-threaded. Implementasi thread pool membantu meningkatkan responsiveness, kinerja, dan skalabilitas sistem secara keseluruhan.
